//! Story-Character relation implementation using macros
//! Handles main characters for stories with --set main_characters=name:role:importance

use crate::define_complete_relation;
use crate::define_relation_db_struct;
use crate::relations::models::Relation;

// ================================
// LOW-LEVEL DATABASE OPERATIONS
// ================================

// Generate the database handler struct for direct CRUD operations
define_relation_db_struct!(
    StoryCharacterDb,
    table: "story_characters",
    key_fields: {
        story_name: String,
        character_name: String
    },
    fields: {
        role: String,
        importance: String,
    },
    create_sql: "CREATE TABLE IF NOT EXISTS story_characters (
        story_name TEXT NOT NULL,
        character_name TEXT NOT NULL,
        role TEXT NOT NULL,
        importance TEXT DEFAULT 'Main',
        created_at TEXT NOT NULL,
        PRIMARY KEY (story_name, character_name),
        FOREIGN KEY (story_name) REFERENCES stories (name) ON DELETE CASCADE,
        FOREIGN KEY (character_name) REFERENCES characters (name) ON DELETE CASCADE
    )"
);

// ================================
// HIGH-LEVEL RELATION (meta-driven)
// ================================

// Generate the complete relation system for meta-driven operations
define_complete_relation!(
    StoryCharacter,
    table: "story_characters",
    key_fields: {
        story_name: String,
        character_name: String
    },
    fields: {
        role: String,
        importance: String,
    },
    sql: "INSERT INTO story_characters (story_name, character_name, role, importance, created_at) VALUES (?1, ?2, ?3, ?4, ?5)",
    update_fields: [role, importance],
    parser: {
        name: parse_story_character_string,
        struct: StoryCharacterRelation,
        format: "character_name:role[:importance]"
    },
    processor: {
        name: process_story_character_relations,
        init_fn: StoryCharacterDb::init_table
    },
    db_struct: StoryCharacterDb
);

// ================================
// BACKWARD COMPATIBILITY
// ================================

// For compatibility with existing code
pub fn init_story_character_tables(conn: &rusqlite::Connection) -> anyhow::Result<()> {
    StoryCharacterDb::init_table(conn)
}

// Get all main characters for a story
pub fn get_story_characters(
    conn: &rusqlite::Connection,
    story_name: &str
) -> anyhow::Result<Vec<(String, String, String)>> {
    let sql = "SELECT character_name, role, importance FROM story_characters WHERE story_name = ?1 ORDER BY importance DESC, character_name";
    
    let mut stmt = conn.prepare(sql)?;
    let rows = stmt.query_map([story_name], |row| {
        Ok((
            row.get::<_, String>(0)?, // character_name
            row.get::<_, String>(1)?, // role
            row.get::<_, String>(2)?, // importance
        ))
    })?;
    
    let mut results = Vec::new();
    for row in rows {
        results.push(row?);
    }
    
    Ok(results)
}

// Get all stories for a character
pub fn get_character_stories(
    conn: &rusqlite::Connection,
    character_name: &str
) -> anyhow::Result<Vec<(String, String, String)>> {
    let sql = "SELECT story_name, role, importance FROM story_characters WHERE character_name = ?1 ORDER BY story_name";
    
    let mut stmt = conn.prepare(sql)?;
    let rows = stmt.query_map([character_name], |row| {
        Ok((
            row.get::<_, String>(0)?, // story_name
            row.get::<_, String>(1)?, // role
            row.get::<_, String>(2)?, // importance
        ))
    })?;
    
    let mut results = Vec::new();
    for row in rows {
        results.push(row?);
    }
    
    Ok(results)
}

// Get character count by importance for a story
pub fn get_story_character_stats(
    conn: &rusqlite::Connection,
    story_name: &str
) -> anyhow::Result<Vec<(String, i32)>> {
    let sql = "SELECT importance, COUNT(*) FROM story_characters WHERE story_name = ?1 GROUP BY importance ORDER BY importance DESC";
    
    let mut stmt = conn.prepare(sql)?;
    let rows = stmt.query_map([story_name], |row| {
        Ok((
            row.get::<_, String>(0)?, // importance
            row.get::<_, i32>(1)?,    // count
        ))
    })?;
    
    let mut results = Vec::new();
    for row in rows {
        results.push(row?);
    }
    
    Ok(results)
}

// ================================
// GENERATED BY MACROS:
// ================================

// High-level (meta-driven):
// - StoryCharacter struct with Relation trait
// - parse_story_character_string() function
// - process_story_character_relations() function
// - StoryCharacterRelation struct for parsing

// Low-level (database):
// - StoryCharacterDb struct with CRUD methods
// - init_table(), insert(), update(), delete(), get_by_first_key()

// Usage examples:
// --set main_characters=aragorn:king
// --set main_characters=frodo:ringbearer:protagonist,sam:companion:main
// --set main_characters=gandalf:wizard:supporting