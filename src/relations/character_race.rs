//! Character-Race relation implementation using macros
//! Handles race assignment to characters with --set race=race_name

use crate::define_complete_relation;
use crate::define_relation_db_struct;
use crate::relations::models::Relation;

// ================================
// LOW-LEVEL DATABASE OPERATIONS
// ================================

// Generate the database handler struct for direct CRUD operations
define_relation_db_struct!(
    CharacterRaceDb,
    table: "character_races",
    key_fields: {
        character_name: String,
        race_name: String
    },
    fields: {
        heritage: String,
        lineage: String,
    },
    create_sql: "CREATE TABLE IF NOT EXISTS character_races (
        character_name TEXT NOT NULL,
        race_name TEXT NOT NULL,
        heritage TEXT DEFAULT 'Pure',
        lineage TEXT DEFAULT 'Unknown',
        created_at TEXT NOT NULL,
        PRIMARY KEY (character_name, race_name),
        FOREIGN KEY (character_name) REFERENCES characters (name) ON DELETE CASCADE,
        FOREIGN KEY (race_name) REFERENCES races (name) ON DELETE CASCADE
    )"
);

// ================================
// HIGH-LEVEL RELATION (meta-driven)
// ================================

// Generate the complete relation system for meta-driven operations
define_complete_relation!(
    CharacterRace,
    table: "character_races",
    key_fields: {
        character_name: String,
        race_name: String
    },
    fields: {
        heritage: String,
        lineage: String,
    },
    sql: "INSERT INTO character_races (character_name, race_name, heritage, lineage, created_at) VALUES (?1, ?2, ?3, ?4, ?5)",
    update_fields: [heritage, lineage],
    parser: {
        name: parse_character_race_string,
        struct: CharacterRaceRelation,
        format: "race_name[:heritage[:lineage]]"
    },
    processor: {
        name: process_character_race_relations,
        init_fn: CharacterRaceDb::init_table
    },
    db_struct: CharacterRaceDb
);

// ================================
// BACKWARD COMPATIBILITY
// ================================

// For compatibility with existing code
pub fn init_character_race_tables(conn: &rusqlite::Connection) -> anyhow::Result<()> {
    CharacterRaceDb::init_table(conn)
}

// Convenience function to get character's race
pub fn get_character_race(
    conn: &rusqlite::Connection,
    character_name: &str
) -> anyhow::Result<Option<(String, String, String)>> {
    let sql = "SELECT race_name, heritage, lineage FROM character_races WHERE character_name = ?1 LIMIT 1";
    
    let mut stmt = conn.prepare(sql)?;
    let mut rows = stmt.query_map([character_name], |row| {
        Ok((
            row.get::<_, String>(0)?, // race_name
            row.get::<_, String>(1)?, // heritage
            row.get::<_, String>(2)?, // lineage
        ))
    })?;
    
    match rows.next() {
        Some(row) => Ok(Some(row?)),
        None => Ok(None),
    }
}

// Get all characters of a specific race
pub fn get_race_characters(
    conn: &rusqlite::Connection,
    race_name: &str
) -> anyhow::Result<Vec<(String, String, String)>> {
    let sql = "SELECT character_name, heritage, lineage FROM character_races WHERE race_name = ?1 ORDER BY character_name";
    
    let mut stmt = conn.prepare(sql)?;
    let rows = stmt.query_map([race_name], |row| {
        Ok((
            row.get::<_, String>(0)?, // character_name
            row.get::<_, String>(1)?, // heritage
            row.get::<_, String>(2)?, // lineage
        ))
    })?;
    
    let mut results = Vec::new();
    for row in rows {
        results.push(row?);
    }
    
    Ok(results)
}

// ================================
// GENERATED BY MACROS:
// ================================

// High-level (meta-driven):
// - CharacterRace struct with Relation trait
// - parse_character_race_string() function
// - process_character_race_relations() function
// - CharacterRaceRelation struct for parsing

// Low-level (database):
// - CharacterRaceDb struct with CRUD methods
// - init_table(), insert(), update(), delete(), get_by_first_key()

// Usage examples:
// --set race=human
// --set race=elf:pure:noble
// --set race=dwarf:mixed:clan_ironforge