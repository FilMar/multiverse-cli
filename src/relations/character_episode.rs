//! Complete Character-Episode relation implementation using macros
//! This file contains both the high-level relation logic and low-level database operations

use crate::define_complete_relation;
use crate::define_relation_db_struct;
use crate::relations::models::Relation;

// ================================
// LOW-LEVEL DATABASE OPERATIONS
// ================================

// Generate the database handler struct for direct CRUD operations - MUST BE FIRST
define_relation_db_struct!(
    CharacterEpisodeDb,
    table: "episode_characters",
    key_fields: {
        episode_id: i32,
        character_name: String
    },
    fields: {
        story: String,
        role: String,
        importance: String,
    },
    create_sql: "CREATE TABLE IF NOT EXISTS episode_characters (
        episode_id INTEGER NOT NULL,
        character_name TEXT NOT NULL,
        story TEXT NOT NULL,
        role TEXT NOT NULL,
        importance TEXT DEFAULT 'Supporting',
        created_at TEXT NOT NULL,
        PRIMARY KEY (episode_id, character_name),
        FOREIGN KEY (episode_id) REFERENCES episodes (id) ON DELETE CASCADE,
        FOREIGN KEY (character_name) REFERENCES characters (name) ON DELETE CASCADE
    )"
);

// ================================
// HIGH-LEVEL RELATION (meta-driven)
// ================================

// Generate the complete relation system for meta-driven operations
define_complete_relation!(
    CharacterEpisode,
    table: "episode_characters",
    key_fields: {
        episode_id: i32,
        character_name: String
    },
    fields: {
        story: String,
        role: String,
        importance: String,
    },
    sql: "INSERT INTO episode_characters (episode_id, character_name, story, role, importance, created_at) VALUES (?1, ?2, ?3, ?4, ?5, ?6)",
    update_fields: [story, role, importance],
    parser: {
        name: parse_character_episode_string,
        struct: EpisodeRelation,
        format: "story:episode:role[:importance]"
    },
    processor: {
        name: process_character_episode_relations,
        init_fn: CharacterEpisodeDb::init_table
    },
    db_struct: CharacterEpisodeDb
);

// ================================
// BACKWARD COMPATIBILITY
// ================================

// For compatibility with existing code that expects function calls
pub fn init_episode_character_tables(conn: &rusqlite::Connection) -> anyhow::Result<()> {
    CharacterEpisodeDb::init_table(conn)
}

// Additional convenience function for reverse lookup
pub fn get_character_episodes(
    conn: &rusqlite::Connection,
    character_name: &str
) -> anyhow::Result<Vec<(i32, String, String)>> {
    let sql = "SELECT episode_id, role, importance FROM episode_characters WHERE character_name = ?1 ORDER BY episode_id";
    
    let mut stmt = conn.prepare(sql)?;
    let rows = stmt.query_map([character_name], |row| {
        Ok((
            row.get::<_, i32>(0)?,    // episode_id
            row.get::<_, String>(1)?, // role
            row.get::<_, String>(2)?  // importance
        ))
    })?;
    
    let mut results = Vec::new();
    for row in rows {
        results.push(row?);
    }
    
    Ok(results)
}

// ================================
// GENERATED BY MACROS:
// ================================

// High-level (meta-driven):
// - CharacterEpisode struct with Relation trait
// - parse_character_episode_string() function
// - process_character_episode_relations() function
// - EpisodeRelation struct for parsing

// Low-level (database):
// - CharacterEpisodeDb struct with CRUD methods
// - init_table(), insert(), update(), delete(), get_by_first_key()

// All with proper error handling, type safety, and consistent patterns!
