//! Episode-Location relation implementation using macros
//! Handles locations where episodes take place with --set locations=name:scene_type:duration

use crate::define_complete_relation;
use crate::define_relation_db_struct;
use crate::relations::models::Relation;

// ================================
// LOW-LEVEL DATABASE OPERATIONS
// ================================

// Generate the database handler struct for direct CRUD operations
define_relation_db_struct!(
    EpisodeLocationDb,
    table: "episode_locations",
    key_fields: {
        episode_id: i32,
        location_name: String
    },
    fields: {
        scene_type: String,
        duration: String,
    },
    create_sql: "CREATE TABLE IF NOT EXISTS episode_locations (
        episode_id INTEGER NOT NULL,
        location_name TEXT NOT NULL,
        scene_type TEXT NOT NULL,
        duration TEXT DEFAULT 'Brief',
        created_at TEXT NOT NULL,
        PRIMARY KEY (episode_id, location_name),
        FOREIGN KEY (episode_id) REFERENCES episodes (id) ON DELETE CASCADE,
        FOREIGN KEY (location_name) REFERENCES locations (name) ON DELETE CASCADE
    )"
);

// ================================
// HIGH-LEVEL RELATION (meta-driven)
// ================================

// Generate the complete relation system for meta-driven operations
define_complete_relation!(
    EpisodeLocation,
    table: "episode_locations",
    key_fields: {
        episode_id: i32,
        location_name: String
    },
    fields: {
        scene_type: String,
        duration: String,
    },
    sql: "INSERT INTO episode_locations (episode_id, location_name, scene_type, duration, created_at) VALUES (?1, ?2, ?3, ?4, ?5)",
    update_fields: [scene_type, duration],
    parser: {
        name: parse_episode_location_string,
        struct: EpisodeLocationRelation,
        format: "location_name:scene_type[:duration]"
    },
    processor: {
        name: process_episode_location_relations,
        init_fn: EpisodeLocationDb::init_table
    },
    db_struct: EpisodeLocationDb
);

// ================================
// BACKWARD COMPATIBILITY
// ================================

// For compatibility with existing code
pub fn init_episode_location_tables(conn: &rusqlite::Connection) -> anyhow::Result<()> {
    EpisodeLocationDb::init_table(conn)
}

// Get all locations for an episode
pub fn get_episode_locations(
    conn: &rusqlite::Connection,
    episode_id: i32
) -> anyhow::Result<Vec<(String, String, String)>> {
    let sql = "SELECT location_name, scene_type, duration FROM episode_locations WHERE episode_id = ?1 ORDER BY scene_type, location_name";
    
    let mut stmt = conn.prepare(sql)?;
    let rows = stmt.query_map([episode_id], |row| {
        Ok((
            row.get::<_, String>(0)?, // location_name
            row.get::<_, String>(1)?, // scene_type
            row.get::<_, String>(2)?, // duration
        ))
    })?;
    
    let mut results = Vec::new();
    for row in rows {
        results.push(row?);
    }
    
    Ok(results)
}

// Get all episodes for a location
pub fn get_location_episodes(
    conn: &rusqlite::Connection,
    location_name: &str
) -> anyhow::Result<Vec<(i32, String, String)>> {
    let sql = "SELECT episode_id, scene_type, duration FROM episode_locations WHERE location_name = ?1 ORDER BY episode_id";
    
    let mut stmt = conn.prepare(sql)?;
    let rows = stmt.query_map([location_name], |row| {
        Ok((
            row.get::<_, i32>(0)?,    // episode_id
            row.get::<_, String>(1)?, // scene_type
            row.get::<_, String>(2)?, // duration
        ))
    })?;
    
    let mut results = Vec::new();
    for row in rows {
        results.push(row?);
    }
    
    Ok(results)
}

// Get location usage statistics
pub fn get_location_episode_stats(
    conn: &rusqlite::Connection,
    location_name: &str
) -> anyhow::Result<Vec<(String, i32)>> {
    let sql = "SELECT scene_type, COUNT(*) FROM episode_locations WHERE location_name = ?1 GROUP BY scene_type ORDER BY COUNT(*) DESC";
    
    let mut stmt = conn.prepare(sql)?;
    let rows = stmt.query_map([location_name], |row| {
        Ok((
            row.get::<_, String>(0)?, // scene_type
            row.get::<_, i32>(1)?,    // count
        ))
    })?;
    
    let mut results = Vec::new();
    for row in rows {
        results.push(row?);
    }
    
    Ok(results)
}

// ================================
// GENERATED BY MACROS:
// ================================

// High-level (meta-driven):
// - EpisodeLocation struct with Relation trait
// - parse_episode_location_string() function
// - process_episode_location_relations() function
// - EpisodeLocationRelation struct for parsing

// Low-level (database):
// - EpisodeLocationDb struct with CRUD methods
// - init_table(), insert(), update(), delete(), get_by_first_key()

// Usage examples:
// --set locations=tavern:dialogue:extended
// --set locations=forest:battle:brief,castle:climax:extended
// --set locations=dungeon:exploration:medium